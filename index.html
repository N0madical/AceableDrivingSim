<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
    canvas {
        background-color: #f1f1f1;
    }
    </style>
</head>
<body onload="startGame()" style="margin: 0px;">
<script>

// --------------------------------------------------------------
// Code Starts Here

// Config
var fps = 60
var zoom = 100


// Defining Variables
var lasttime = 0;
var fpsrec = 0;

let left = false;
let right = false;
let up = false;
let down = false;

// Launch The Game
function startGame() {
    gameWindow.start(0, 0, 0, zoom);
    player.start();
    test = new testdot();
    fpscount = new displaytext(100, 100, "FPS: Error", "30px")
    speedometer = new displaytext(100, 150, "Speed: Error", "30px")
    posdebug = new displaytext(100, 200, "Position: Error", "30px")

    spritelist = [player, fpscount, speedometer, posdebug]

    terrain = [
        new rect(0, 0, 0, 5000, 5000, "darkgreen"), 
        new rect(0, 0, 0, 600, 800, "darkgray"),
        new rect(150, 500, 30, 100, 200, "darkgray"),

        new rect(-150, 500, -30, 100, 200, "darkgray"),
        new rect(0, 460, 0, 300, 300, "darkgray"),
        new rect(0, 700, 0, 1000, 300, "darkgray"),
        new rect(0, 550, 0, 1000, 10, "dimgray"),
        new rect(0, 850, 0, 1000, 10, "dimgray"),

        new rect(-400, 700, 0, 100, 10, "yellow"),
        new rect(-200, 700, 0, 100, 10, "yellow"),
        new rect(0, 700, 0, 100, 10, "yellow"),
        new rect(200, 700, 0, 100, 10, "yellow"),
        new rect(400, 700, 0, 100, 10, "yellow"),

        new rect(225, -300, 45, 10, 200, "yellow"), 
        new rect(225, -150, 45, 10, 200, "yellow"),
        new rect(225, 0, 45, 10, 200, "yellow"), 
        new rect(225, 150, 45, 10, 200, "yellow"),
        new rect(225, 300, 45, 10, 200, "yellow"),

        new rect(-225, -300, -45, 10, 200, "yellow"), 
        new rect(-225, -150, -45, 10, 200, "yellow"),
        new rect(-225, 0, -45, 10, 200, "yellow"), 
        new rect(-225, 150, -45, 10, 200, "yellow"),
        new rect(-225, 300, -45, 10, 200, "yellow"),

        new rect(-300, 0, 0, 20, 800, "dimgray"),
        new rect(300, 0, 0, 20, 800, "dimgray"),
    ]
    
    updatelist = terrain.concat(spritelist);
}

var gameWindow = {
    canvas : document.createElement("canvas"),
    start : function(x=0, y=0, angle=0, zoom=100) {

        // Starting Variables For Canvas
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight - 5;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        camera.start(x,y,angle,zoom);

        // Start Refresh
        this.interval = setInterval(updateGameWindow, (1000/fps));

        // Keyboard Listeners
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            gameWindow.keys = (gameWindow.keys || []);
            gameWindow.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            gameWindow.keys[e.keyCode] = (e.type == "keydown");
        })
    },

    // Wipe Canvas To Create Refresh Effect
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

var camera = {
    start : function(x, y, angle, zoom) {
        this.cx = x;
        this.cy = y;
        this.cangle = angle;
        this.czoom = zoom;
    },

    position : function(x, y, rot) {
        distance = Math.sqrt(Math.pow(x-this.cx,2)+Math.pow(y-this.cy,2))*(this.czoom/100)
        angle = degrees(Math.atan2((y-this.cy),(x-this.cx)))+this.cangle
        x2 = (Math.cos(radians(angle))*distance)
        y2 = (Math.sin(radians(angle))*distance)
        angle2 = rot - this.cangle
        return [x2, y2, angle2, angle]
    }
}

var player = {
    start : function(x, y, angle, zoom) {
        // Config For The Car
        this.deceleration = 0.1
        this.turnback = 0.1

        // Defining Starting Variables On Creation
        this.width = 100;
        this.height = this.width*2;
        this.speed = 0;
        this.rotation = 0;
        this.carimage = new Image();
        this.carimage.src = "car.png";
    },

    // Move The Sprite When Update Is Called
    update : function() {
        // Update Positions
        if (this.speed > 0) {
            camera.cangle += this.rotation * (this.speed/5);
        }
        if (this.speed < 0) {
            camera.cangle += this.rotation * (this.speed/5);
        }
        camera.cx += this.speed * Math.sin(radians(camera.cangle));
        camera.cy += this.speed * Math.cos(radians(camera.cangle));
        

        // Physics
        if (!up && !down) {
            if (this.speed > 0) {this.speed -= this.deceleration; if(this.speed <=0){this.speed=0}} 
            else if (this.speed < 0) {this.speed += this.deceleration; if(this.speed >=0){this.speed=0}}
            else {this.speed = 0}
        }
        
        if (this.rotation > 0 && !(left || right)) {this.rotation -= this.turnback * Math.abs(this.speed); if(this.rotation <=0){this.rotation=0}} 
        else if (this.rotation < 0 && !(left || right)) {this.rotation += this.turnback * Math.abs(this.speed); if(this.rotation >=0){this.rotation=0}}
        else if (!(left || right)) {this.rotation = 0}

        // Update Visuals
        wheelL = gameWindow.context;
        wheelL.save();
        wheelL.translate(((gameWindow.canvas.width/2 - this.width/3.4*(camera.czoom/100))), ((gameWindow.canvas.height/2 - this.height/3.8*(camera.czoom/100))));
        wheelL.rotate(radians(this.rotation*20));
        wheelL.fillStyle = "black";
        wheelL.fillRect((this.width/10*(camera.czoom/100)) / -2, (this.height/6*(camera.czoom/100)) / -2, this.width/10*(camera.czoom/100), this.height/6*(camera.czoom/100));
        wheelL.restore();

        wheelR = gameWindow.context;
        wheelR.save();
        wheelR.translate(((gameWindow.canvas.width/2 + this.width/3.4*(camera.czoom/100))), ((gameWindow.canvas.height/2 - this.height/3.8*(camera.czoom/100))));
        wheelR.rotate(radians(this.rotation*20));
        wheelR.fillStyle = "black";
        wheelR.fillRect((this.width/10*(camera.czoom/100)) / -2, (this.height/6*(camera.czoom/100)) / -2, this.width/10*(camera.czoom/100), this.height/6*(camera.czoom/100));
        wheelR.restore();

        car = gameWindow.context;
        car.fillStyle = "purple";
        car.drawImage(this.carimage, gameWindow.canvas.width/2-(this.width/2*(camera.czoom/100)), gameWindow.canvas.height/2-(this.height/2*(camera.czoom/100)), this.width*(camera.czoom/100), this.height*(camera.czoom/100));
    }
}

function rect(x, y, angle, width, height, color="black") {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.width = width;
    this.height = height;
    this.color = color;

    this.update = function() {
        canvas = gameWindow.context;
        canvas.save();
        pos = camera.position(this.x,this.y,this.angle)
        canvas.translate(((gameWindow.canvas.width/2 + pos[0])), ((gameWindow.canvas.height/2 - pos[1])));
        canvas.rotate(radians(pos[2]));
        canvas.fillStyle = this.color;
        canvas.fillRect((this.width*(camera.czoom/100)) / -2, (this.height*(camera.czoom/100)) / -2, this.width*(camera.czoom/100), this.height)*(camera.czoom/100);
        canvas.restore();
    }
}

function testdot() {
    this.x = 100
    this.y = 100
    this.width = 50
    this.height = 50
    this.angle = 0

    this.update = function() {
        canvas = gameWindow.context;
        canvas.fillStyle = "purple";
        canvas.fillRect(camera.position(this.x,this.y,this.angle)[0], camera.position(this.x,this.y,this.angle)[1], this.width, this.height);
    }
}

function displaytext(x, y, text, size, font="Arial") {
    this.x = x;
    this.y = y;
    this.text = text;
    this.size = size;
    this.font = font;

    this.update = function() {
        canvas = gameWindow.context;
        canvas.font = (`${this.size} ${this.font}`);
        canvas.fillText(this.text, this.x, this.y);
    }
}

// Refresh The Canvas (50x per second)
function updateGameWindow() {
    const d = new Date();
    fpsrec += 1
    if (lasttime + 250 <= d.getTime()) {
        lasttime = d.getTime();
        fpscount.text = `FPS: ${fpsrec * 4} / ${fps}`;
        speedometer.text = `Speed: ${player.speed}, Rotation: ${player.rotation}`
        posdebug.text = `Position: ${camera.cx}, ${camera.cy}, ${camera.cangle}`
        fpsrec = 0;
    }

    // Defining Keypresses
    if (gameWindow.keys && (gameWindow.keys[37] || gameWindow.keys[65])) {left = true} else {left = false}
    if (gameWindow.keys && (gameWindow.keys[39] || gameWindow.keys[68])) {right = true} else {right = false}
    if (gameWindow.keys && (gameWindow.keys[38] || gameWindow.keys[87])) {up = true} else {up = false}
    if (gameWindow.keys && (gameWindow.keys[40] || gameWindow.keys[83])) {down = true} else {down = false}

    // ############# Keycode Finder ############
    // if (gameWindow.keys) {
    //     for(i = 0; i < gameWindow.keys.length; i++) {
    //         if (gameWindow.keys[i])
    //             console.debug(`Key ${i} pressed`);
    //     }
    // }
    
    // Movement
    gameWindow.clear();
    if (left && (player.rotation > -2)) {player.rotation += -0.1; }
    if (right && (player.rotation < 2)) {player.rotation += 0.1; }
    if (up && (player.speed < 5)) {player.speed += 0.1; }
    if (down && (player.speed > -5)) {player.speed += -0.1; }
    
    for(i = 0; i < updatelist.length; i++) {
        updatelist[i].update();
    }
}

function degrees(radians) {return (radians * (180/Math.PI)) % 360}
function radians(degrees) {return degrees * (Math.PI/180)}

// --------------------------------------------------------------

</script>
</body>
</html>
 
